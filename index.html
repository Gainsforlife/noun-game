<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Noun Game ‚Äì Mobile Drag White Theme (prefetch + quicker video loads)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <style>
/* (styles unchanged except minor whitespace) */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  background: #fff !important;
}
body {
  min-height: 100vh !important;
  background: #fff !important;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  padding: 0;
  overflow-x: hidden;
  overflow-y: auto;
}
.app-wrapper {
  background: #fff !important;
  border-radius: 0;
  max-width: 100vw;
  width: 100vw;
  min-height: 100vh;
  height: 100vh;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: hidden;
}
.app-header { text-align: center; padding: 2vw 0; width: 100vw; background: #fff;}
.app-header h1 { font-size:7vw; color:#111; margin-bottom:.5vw; letter-spacing:.05em;}
.app-header p { color:#444; font-size:4vw; margin-top:1vw;}
#score-header { display:flex; gap:4vw; align-items:center; justify-content:center; margin:2vw auto; flex-wrap:wrap; width:86vw; position:relative; flex-shrink:0; background: #fff;}
.score-marker { width:14vw; height:14vw; border:3px solid #FF6B35; border-radius:3vw; background:#fff; box-sizing:border-box; margin-right:.2vw; display:flex; align-items:center; justify-content:center; overflow:hidden;}
.score-marker img { width:8vw; height:8vw; object-fit:contain;}
.points-display { background:#2563EB; color:#fff; padding:2vw 4vw; border-radius:2vw; font-weight:700; font-size:5vw; box-shadow:0 3px 10px rgba(102,126,234,.14); letter-spacing:.04em;}
.points-label { font-size:3vw; text-transform:uppercase; letter-spacing:.09em;}
.points-value { font-size:8vw; font-weight:800; line-height:1;}
#game-container { width:100vw; flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:3vw; min-height:0; background: #fff;}
.game-content { width:100vw; margin:0; padding:0; display:flex; flex-direction:column; align-items:center; justify-content:center; background: #fff;}
#content-wrapper { width:100vw; display:flex; flex-direction:column; align-items:center; justify-content:center; background: #fff;}
#video-section { position:relative; width:100vw; max-width:100vw; height:auto; margin:0 auto 3vw auto; box-sizing:border-box; display:flex; justify-content:center; align-items:center; background: #fff;}
#prompt-video { width:100vw; max-width:100vw; height:auto; display:block; background:#fff; border-radius:0; object-fit:contain; z-index:1; margin:0;}
#noun-img-container { position:absolute; top:2vw; right:2vw; z-index:2; width:50vw; height:auto; display:flex; justify-content:flex-end; align-items:flex-start; pointer-events:auto; background: transparent;}
.noun-img { width:100%; height:auto; max-width:100%; border-radius:4vw; padding:1vw; background:#f3f3f3; border:2px solid #FF6B35; object-fit:contain; box-sizing:border-box; margin:0;}
.controls { width:94vw; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; margin-top:2vw; margin-bottom:2vw; flex-shrink:0; background: #fff;}
.btn-replay { padding:3vw 0; border-radius:2vw; border:none; width:74vw; background:#2563EB; color:#fff; font-size:6vw; font-weight:700; margin:0 auto; transition:background .3s; margin-bottom:2vw; box-shadow:0 4px 20px rgba(90,103,216,.08); letter-spacing:.05em;}
#audio-cards { width:100vw; display:flex; justify-content:center; gap:4vw; flex-wrap:wrap; padding-bottom:2vw; background: #fff;}
.audio-card { display:flex; flex-direction:row; align-items:center; justify-content:center; gap:2vw; padding:4vw 5vw; border-radius:2vw; background:#f3f3f3; box-shadow:0 4px 20px rgba(102,126,234,.08); cursor:grab; border:3px solid #2563EB; font-size:5vw; color:#222; font-weight:700; min-width:34vw; max-width:43vw; text-align:center; margin-bottom:2vw; user-select:none; -webkit-user-select:none; transition:box-shadow .2s,border-color .2s;}
.audio-card span { font-size:4vw; text-transform:uppercase; font-family:inherit; font-weight:700; letter-spacing:.05em; margin-right:1vw;}
.audio-card button { background:rgba(60,60,60,.10); border:2px solid #2563EB; border-radius:50%; width:9vw; height:9vw; font-size:6vw; cursor:pointer; display:flex; align-items:center; justify-content:center; color:#2563EB; margin-left:.5vw; margin-right:.5vw; transition:background .2s;}
.audio-card button:active { background:rgba(60,60,60,.18);}
.audio-card:active, .audio-card.touching { box-shadow:0 8px 30px rgba(102,126,234,.14); border-color:#2563EB; opacity:0.92;}
.audio-card.dragging { opacity:0.8; box-shadow:0 12px 40px rgba(102,126,234,.13);}
.drag-clone { background: #f3f3f3; position: fixed; pointer-events: none; z-index: 9999; opacity: 0.9; box-shadow: 0 18px 40px #aaa; transform: scale(1.08) rotate(2deg); transition: none; }
@media (min-width:700px) {
  .app-header, .game-content, #content-wrapper, #video-section, #prompt-video, body, html, .app-wrapper {
    background: #fff !important;
  }
}
  </style>
</head>
<body>
  <div class="app-wrapper">
    <div class="app-header">
      <h1>üéÆ Noun Game</h1>
      <p> Â∞ÜÈü≥È¢ëÂç°ÊãñÂà∞ÂõæÁâá‰∏ä</p>
    </div>
    <div id="score-header"></div>
    <div id="game-container">
      <div class="game-content">
        <div id="content-wrapper">
          <div id="video-section">
            <!--
              Improvements:
              - preload="auto" and muted: increases the chance the browser will fetch and allow autoplay
              - crossorigin="anonymous" to allow cross-origin prefetching if needed
              - poster can be set to a lightweight placeholder to reduce layout shift while the video is downloading
            -->
            <video id="prompt-video" autoplay muted playsinline preload="auto" crossorigin="anonymous"></video>
            <div id="noun-img-container">
              <img id="noun-img" class="noun-img" src="" alt="noun">
            </div>
          </div>
        </div>
      </div>
      <div class="controls">
        <button class="btn-replay" onclick="playPromptVideo()"> ÂºÄÂßãËßÜÈ¢ë</button>
      </div>
      <div id="audio-cards"></div>
    </div>
  </div>

  <script>
    // Data
    const nouns = [
      { name: 'butterfly', img: 'img/Butterfly.png', audio: 'audio/butterfly.mp3' },
      { name: 'duck', img: 'img/duck.png', audio: 'audio/duck.mp3' },
      { name: 'turtle', img: 'img/turtle.png', audio: 'audio/turtle.mp3' },
      { name: 'frog', img: 'img/frog.png', audio: 'audio/frog.mp3' },
      { name: 'dolphin', img: 'img/dolphin.png', audio: 'audio/dolphin.mp3' },
      { name: 'fish', img: 'img/fish.png', audio: 'audio/fish.mp3' },
      { name: 'bee', img: 'img/bee.png', audio: 'audio/bee.mp3' },
      { name: 'plane', img: 'img/plane.png', audio: 'audio/plane.mp3' },
      { name: 'bat', img: 'img/bat.png', audio: 'audio/bat.mp3' },
      { name: 'bird', img: 'img/bird.png', audio: 'audio/bird.mp3' }
    ];
    const whatisthisVideos = [
      'vid/whatisthis.mp4',
      'vid/whatisthis1.mp4',
      'vid/whatisthis2.mp4'
    ];

    // Playback and scoring state
    let videoQueue = [];
    let lastVideo = null;
    const streakLength = 5;
    const pointsGoal = 3;
    let streak = 0;
    let totalPoints = 0;
    let scoreMarkers = [];
    let gameWon = false;
    let celebrationInProgress = false;

    // --- PERFORMANCE HELPERS: prefetch / preload --
    // Use <link rel="preload" as="video"> to hint the browser to fetch video bytes early.
    // Also keep links deduplicated by url so we don't create duplicates.
    const _preloadLinks = new Map();
    function prefetchVideo(url, type = 'video/mp4') {
      if (!url) return;
      // don't prefetch if save-data is enabled
      if (navigator.connection && navigator.connection.saveData) return;
      if (_preloadLinks.has(url)) return;
      try {
        const link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'video';
        link.href = url;
        if (type) link.type = type;
        // crossorigin for CDNs that require it
        link.crossOrigin = 'anonymous';
        document.head.appendChild(link);
        _preloadLinks.set(url, link);
      } catch (e) {
        // ignore silently if unsupported
      }
    }

    // small adaptive hint: if the connection is slow, avoid preloading everything
    function shouldAggressivelyPrefetch() {
      if (navigator.connection) {
        const c = navigator.connection;
        // treat 4g as ok, otherwise be conservative
        if (c.saveData) return false;
        if (c.effectiveType && (c.effectiveType.includes('2g') || c.effectiveType.includes('3g'))) return false;
      }
      return true;
    }

    // --- existing helpers (unchanged logic, mild integration) ---
    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // When we build/refresh the queue, prefetch the next 1-2 clips to reduce wait.
    function buildVideoQueue() {
      videoQueue = shuffleArray(whatisthisVideos.slice());
      // ensure we don't repeat last video at the top
      if (videoQueue[0] === lastVideo && videoQueue.length > 1) {
        [videoQueue[0], videoQueue[1]] = [videoQueue[1], videoQueue[0]];
      }
      // prefetch the first two items if conditions allow
      if (shouldAggressivelyPrefetch()) {
        prefetchVideo(videoQueue[0]);
        if (videoQueue.length > 1) prefetchVideo(videoQueue[1]);
      }
    }

    function getNextWhatisthisVideo() {
      if (videoQueue.length <= 1) {
        buildVideoQueue();
      }
      const next = videoQueue.shift();
      lastVideo = next;
      // prefetch the upcoming one (if any) to reduce next-round latency
      if (shouldAggressivelyPrefetch() && videoQueue.length > 0) {
        prefetchVideo(videoQueue[0]);
      }
      return next;
    }

    // Quickly set the <video> src and call load() to encourage the browser to start fetching.
    function setPromptVideoSrc(url) {
      const video = document.getElementById('prompt-video');
      if (!video) return;
      // Remove any existing <source> children, then create a new <source> element.
      while (video.firstChild) video.removeChild(video.firstChild);
      const source = document.createElement('source');
      source.src = url;
      // attempt to hint the type (adjust if you actually serve webm/mp4, etc.)
      source.type = 'video/mp4';
      video.appendChild(source);

      // calling load() tells the browser to (re)load the current source and use preload hints
      try {
        video.load();
      } catch (e) {
        // some older browsers may throw, ignore
      }

      // try to play automatically when enough data is available
      // we attach 'canplay' once to remove race with autoplay policy
      function tryPlayOnCanPlay() {
        video.removeEventListener('canplay', tryPlayOnCanPlay);
        // Only call play if user hasn't blocked autoplay: it might be muted (we set muted=true).
        video.play().catch(() => {
          // If play fails (autoplay policy), we silently ignore - user can tap replay button.
        });
      }
      video.addEventListener('canplay', tryPlayOnCanPlay, { once: true });
    }

    // --- Score UI helpers (unchanged) ---
    function setupScoreHeader() {
      const header = document.getElementById('score-header');
      header.innerHTML = '';
      scoreMarkers = [];
      for (let i = 0; i < streakLength; i++) {
        const div = document.createElement('div');
        div.className = 'score-marker';
        div.innerHTML = '';
        header.appendChild(div);
        scoreMarkers.push(div);
      }
      const pointsDiv = document.createElement('div');
      pointsDiv.className = 'points-display';
      pointsDiv.innerHTML = `<div class="points-label">Points</div><div class="points-value" id="points-counter">0</div>`;
      header.appendChild(pointsDiv);
      document.getElementById('points-counter').textContent = totalPoints;
    }
    function animateStarToProgressBar(targetMarkerIndex) {
      setTimeout(() => {
        scoreMarkers[targetMarkerIndex].innerHTML = '<img src="img/star.png" width="40">';
      }, 600);
    }
    function removeLastStar() {
      for (let i = scoreMarkers.length - 1; i >= 0; i--) {
        const marker = scoreMarkers[i];
        if (marker.innerHTML.trim() !== '') {
          marker.innerHTML = '';
          break;
        }
      }
    }
    function resetGame() {
      gameWon = false;
      celebrationInProgress = false;
      totalPoints = 0;
      streak = 0;
      document.querySelector('.app-header').classList.remove('hidden');
      document.querySelector('#score-header').classList.remove('hidden');
      document.querySelector('.controls').classList.remove('hidden');
      document.querySelector('#audio-cards').classList.remove('hidden');
      document.querySelector('#noun-img-container').classList.remove('hidden');
      setupScoreHeader();
      loadNewRound();
    }
    function playCelebration() {
      gameWon = true;
      celebrationInProgress = true;
      document.querySelector('.app-header').classList.add('hidden');
      document.querySelector('#score-header').classList.add('hidden');
      document.querySelector('.controls').classList.add('hidden');
      document.querySelector('#audio-cards').classList.add('hidden');
      document.querySelector('#noun-img-container').classList.add('hidden');
      setTimeout(() => { resetGame(); }, 2000);
    }
    function updateScoreHeader(isCorrect) {
      if (gameWon || celebrationInProgress) return;
      if (isCorrect) {
        streak++;
        animateStarToProgressBar(streak - 1);
        if (streak === streakLength) {
          totalPoints++;
          updatePointsDisplay();
          if (totalPoints === pointsGoal) {
            playCelebration();
            return;
          } else {
            streak = 0;
            setTimeout(() => { setupScoreHeader(); }, 600);
          }
        }
      } else {
        if (streak > 0) {
          removeLastStar();
          streak--;
        }
      }
    }
    function updatePointsDisplay() {
      const pointsCounter = document.getElementById('points-counter');
      if (pointsCounter)
        pointsCounter.textContent = totalPoints;
    }

    // --- Core game flow ---
    function loadNewRound() {
      if (gameWon || celebrationInProgress) return;
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      document.getElementById('noun-img').src = noun.img;
      document.getElementById('noun-img').setAttribute('data-noun', noun.name);

      // Get next video URL (this function now prefetches the upcoming item too)
      const videoUrl = getNextWhatisthisVideo();

      // Use the helper to set the <source> and trigger load() / play on canplay
      setPromptVideoSrc(videoUrl);

      // select incorrect card
      let incorrect;
      do {
        incorrect = nouns[Math.floor(Math.random() * nouns.length)];
      } while (incorrect.name === noun.name);

      let audioCards = [
        { name: noun.name, audio: noun.audio, correct: true },
        { name: incorrect.name, audio: incorrect.audio, correct: false }
      ];
      audioCards.sort(() => Math.random() - 0.5);
      const audioCardsDiv = document.getElementById('audio-cards');
      audioCardsDiv.innerHTML = '';
      audioCards.forEach((card) => {
        const div = document.createElement('div');
        div.className = 'audio-card';
        div.setAttribute('draggable', true);
        div.setAttribute('data-correct', card.correct);
        div.innerHTML = `<span>${card.name}</span>
          <button onclick="event.stopPropagation(); playAudio('${card.audio}')">üîà</button>`;
        div.addEventListener('dragstart', function(e){
          if (gameWon || celebrationInProgress) { e.preventDefault(); return; }
          e.dataTransfer.setData('text/plain', card.correct);
          div.classList.add('dragging');
        });
        div.addEventListener('dragend', function(e){ div.classList.remove('dragging'); });
        audioCardsDiv.appendChild(div);
      });
      let nounImg = document.getElementById('noun-img');
      nounImg.ondragover = e => e.preventDefault();
      nounImg.ondrop = function(e){
        e.preventDefault();
        if (gameWon || celebrationInProgress) return;
        const correct = (e.dataTransfer.getData('text/plain') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false);}
      };
    }

    function playAudio(audioPath) {
      if (gameWon || celebrationInProgress) return;
      const audio = new Audio(audioPath);
      audio.play();
    }
    function playPromptVideo() {
      if (gameWon || celebrationInProgress) return;
      const vid = document.getElementById('prompt-video');
      vid.currentTime = 0;
      vid.play().catch(()=>{});
    }
    function playFeedback(isCorrect) {
      if (gameWon || celebrationInProgress) return;
      const promptVideo = document.getElementById('prompt-video');
      // switch to immediate feedback clip; we prefetch these feedback clips too in advance below
      promptVideo.src = isCorrect ? 'vid/thatscorrect.mp4' : 'vid/betterluck.mp4';
      promptVideo.loop = false;
      promptVideo.onended = null;
      promptVideo.onended = function() {
        if (!gameWon && !celebrationInProgress) {
          promptVideo.onended = null;
          if (isCorrect) updateScoreHeader(true);
          setTimeout(loadNewRound, 500);
        }
      };
      // reload and play
      try { promptVideo.load(); } catch(e){}
      promptVideo.play().catch(()=>{});
    }

    // --- TOUCH DRAG SUPPORT WITH DRAG CLONE (unchanged) ---
    let touchItem = null;
    let dragClone = null;
    document.addEventListener('touchstart', function(e) {
      const card = e.target.closest('.audio-card');
      if (card && !(gameWon || celebrationInProgress)) {
        touchItem = card;
        card.classList.add('touching');
        dragClone = card.cloneNode(true);
        dragClone.className = "audio-card drag-clone";
        dragClone.style.width = card.offsetWidth + "px";
        dragClone.style.height = card.offsetHeight + "px";
        document.body.appendChild(dragClone);
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - card.offsetWidth/2) + "px";
        dragClone.style.top = (touch.clientY - card.offsetHeight/2) + "px";
      }
    },{passive:false});
    document.addEventListener('touchmove', function(e) {
      if (dragClone && touchItem) {
        e.preventDefault();
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - dragClone.offsetWidth/2) + "px";
        dragClone.style.top = (touch.clientY - dragClone.offsetHeight/2) + "px";
      }
    },{passive:false});
    document.addEventListener('touchend', function(e) {
      if (dragClone) dragClone.remove();
      dragClone = null;
      const touch = e.changedTouches[0];
      const nounImg = document.getElementById('noun-img');
      const rect = nounImg.getBoundingClientRect();
      if (
        touchItem &&
        touch.clientX >= rect.left && touch.clientX <= rect.right &&
        touch.clientY >= rect.top && touch.clientY <= rect.bottom
      ) {
        const correct = (touchItem.getAttribute('data-correct') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false);}
      }
      if (touchItem) touchItem.classList.remove('touching');
      touchItem = null;
    },{passive:false});

    // --- INITIALIZATION: prefetch feedback clips and build queue early ---
    (function init() {
      setupScoreHeader();

      // prefetch feedback clips (small number) so feedback plays instantly
      if (shouldAggressivelyPrefetch()) {
        prefetchVideo('vid/thatscorrect.mp4');
        prefetchVideo('vid/betterluck.mp4');
      }

      // build/shuffle queue and prefetch first items
      buildVideoQueue();

      // Immediately start a round ‚Äî getNextWhatisthisVideo will shift and prefetch next
      loadNewRound();
    })();

  </script>
</body>
</html>
