<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Noun Game ‚Äî Audio On Drag (No Overlap)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="color-scheme" content="only light">
  <style>
html, body {
  height: 100%;
  margin: 0; padding: 0; background: #fff !important; color-scheme: only light;
}
body {
  min-height: 100vh !important;
  background: #fff !important;
  color-scheme: only light;
  display: flex; align-items: center; justify-content: center; width: 100vw; padding: 0;
  overflow-x: hidden; overflow-y: auto;
}
.app-wrapper, #game-container, .game-content, #content-wrapper, #video-section, #audio-cards, .controls,
.app-header, .points-display, .score-marker {
  background: #fff !important;
}
#score-header { display: flex; gap: 2vw; align-items: center; justify-content: center; margin: 2vw auto 2vw auto; flex-wrap: wrap; width: 100vw; position: relative; background: #fff; }
.score-marker { width: 9vw; height: 9vw; min-width: 26px; min-height: 26px; border: 2.5px solid #FFC100; background: #fff; border-radius: 2vw; margin: 0 1vw; display: flex; align-items: center; justify-content: center; font-size: 6vw; color: #FFC100; box-shadow: 0 3px 10px #eed37a20; transition: background 0.2s;}
.star-empty { opacity: 0.3; filter: grayscale(1); }
.score-marker img { width: 80%; max-width: 32px; height: auto; object-fit: contain; }
.app-header h1 { color: #191919; }
.app-header p { color: #424242; }
.points-display { background: #2563EB !important; color:#fff; padding:2vw 4vw; border-radius:2vw; font-weight:700; font-size:5vw; box-shadow:0 3px 10px rgba(102,126,234,.08);}
.points-label { font-size:3vw; text-transform:uppercase; letter-spacing:.09em;}
.points-value { font-size:8vw; font-weight:800; line-height:1;}
#game-container { width:100vw; flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:3vw; min-height:0;}
.game-content { width:100vw; margin:0; padding:0; display:flex; flex-direction:column; align-items:center; justify-content:center;}
#content-wrapper { width:100vw; display:flex; flex-direction:column; align-items:center; justify-content:center;}
#video-section { position:relative; width:100vw; max-width:100vw; height:auto; margin:0 auto 3vw auto; box-sizing:border-box; display:flex; justify-content:center; align-items:center;}
#prompt-video { width:100vw; max-width:100vw; height:auto; display:block; background:#fff !important; border-radius:0; object-fit:contain; z-index:1; margin:0;}
#noun-img-container { position:absolute; top:2vw; right:2vw; z-index:2; width:50vw; height:auto; display:flex; justify-content:flex-end; align-items:flex-start; pointer-events:auto;}
.noun-img { width:100%; height:auto; max-width:100%; border-radius:4vw; padding:1vw; background:#f3f3f3 !important; border:2px solid #FF6B35; object-fit:contain; box-sizing:border-box; margin:0;}
.controls { width:94vw; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; margin-top:2vw; margin-bottom:2vw; flex-shrink:0;}
.btn-replay { padding:3vw 0; border-radius:2vw; border:none; width:74vw; background:#2563EB; color:#fff; font-size:6vw; font-weight:700; margin:0 auto; transition:background .3s; margin-bottom:2vw; box-shadow:0 4px 20px rgba(90,103,216,.08); letter-spacing:.05em;}
#audio-cards { width:100vw; display:flex; justify-content:center; gap:4vw; flex-wrap:wrap; padding-bottom:2vw;}
.audio-card { display:flex; flex-direction:row; align-items:center; justify-content:center; gap:2vw; padding:4vw 5vw; border-radius:2vw; background:#f3f3f3 !important; box-shadow:0 4px 20px rgba(102,126,234,.04); cursor:grab; border:3px solid #2563EB; font-size:5vw; color:#222; font-weight:700; min-width:34vw; max-width:43vw; text-align:center; margin-bottom:2vw; user-select:none; -webkit-user-select:none; transition:box-shadow .2s,border-color .2s;}
.audio-card span { font-size:4vw; text-transform:uppercase; font-family:inherit; font-weight:700; letter-spacing:.05em; margin-right:1vw;}
.audio-card button { background:rgba(60,60,60,.08); border:2px solid #2563EB; border-radius:50%; width:9vw; height:9vw; font-size:6vw; cursor:pointer; display:flex; align-items:center; justify-content:center; color:#2563EB; margin-left:.5vw; margin-right:.5vw; transition:background .2s;}
.audio-card button:active { background:rgba(60,60,60,.14);}
.audio-card:active, .audio-card.touching { box-shadow:0 8px 30px rgba(102,126,234,.07); border-color:#2563EB; opacity:0.92;}
.audio-card.dragging { opacity:0.8; box-shadow:0 12px 40px rgba(102,126,234,.07);}
.drag-clone { background: #f3f3f3 !important; position: fixed; pointer-events: none; z-index: 9999; opacity: 0.9; box-shadow: 0 18px 40px #aaa; transform: scale(1.08) rotate(2deg); transition: none; }
.hide-celebration { display: none !important; }
@media (min-width:700px) {
  .app-header, .game-content, #content-wrapper, #video-section, #prompt-video, body, html, .app-wrapper { background: #fff !important; }
}
  </style>
</head>
<body>
  <div class="app-wrapper">
    <div class="app-header">
      <h1>üéÆ Noun Game</h1>
      <p>Â∞ÜÈü≥È¢ëÂç°ÊãñÂà∞ÂõæÁâá‰∏ä</p>
    </div>
    <div id="score-header"></div>
    <div id="game-container">
      <div class="game-content">
        <div id="content-wrapper">
          <div id="video-section">
            <video id="prompt-video" autoplay playsinline preload="auto"></video>
            <div id="noun-img-container">
              <img id="noun-img" class="noun-img" src="" alt="noun">
            </div>
          </div>
        </div>
      </div>
      <div class="controls">
        <button class="btn-replay" onclick="playPromptVideo()">ÂºÄÂßãËßÜÈ¢ë</button>
      </div>
      <div id="audio-cards"></div>
    </div>
  </div>

  <script>
    // ------------------------------
    // Data & configuration
    // ------------------------------
    const streakLength = 5;
    const pointsGoal = 3;
    const nouns = [
      { name: 'butterfly', img: 'img/Butterfly.png', audio: 'audio/butterfly.mp3' },
      { name: 'duck', img: 'img/duck.png', audio: 'audio/duck.mp3' },
      { name: 'turtle', img: 'img/turtle.png', audio: 'audio/turtle.mp3' },
      { name: 'frog', img: 'img/frog.png', audio: 'audio/frog.mp3' },
      { name: 'dolphin', img: 'img/dolphin.png', audio: 'audio/dolphin.mp3' },
      { name: 'fish', img: 'img/fish.png', audio: 'audio/fish.mp3' },
      { name: 'bee', img: 'img/bee.png', audio: 'audio/bee.mp3' },
      { name: 'plane', img: 'img/plane.png', audio: 'audio/plane.mp3' },
      { name: 'bat', img: 'img/bat.png', audio: 'audio/bat.mp3' },
      { name: 'bird', img: 'img/bird.png', audio: 'audio/bird.mp3' }
    ];
    const whatisthisVideos = [
      'vid/whatisthis.mp4', 'vid/whatisthis1.mp4', 'vid/whatisthis2.mp4'
    ];
    const celebrationVideo = 'vid/greatjob.mp4';
    const feedbackVideos = ['vid/thatscorrect.mp4', 'vid/betterluck.mp4'];

    // ------------------------------
    // Shared media queue & players
    // Prevent audio/video overlap by queueing media requests.
    // Behavior: any requested media (audio OR video) is enqueued. If nothing is playing it starts immediately.
    // While playing, new requests wait in FIFO order. When current media ends, next item starts.
    // Each queued item may include an onEnded callback that will be executed after the media finishes.
    // ------------------------------
    const promptVideo = document.getElementById('prompt-video');
    const audioPlayer = new Audio();
    audioPlayer.preload = 'auto';

    let mediaQueue = []; // {type:'audio'|'video', src: string, onEnded: function|null}
    let currentMedia = null; // same shape as queue item while playing

    function enqueueMedia(item) {
      // item: { type, src, onEnded }
      if (!currentMedia) {
        startMedia(item);
      } else {
        mediaQueue.push(item);
      }
    }

    function startMedia(item) {
      currentMedia = item || null;
      if (!item) return;
      if (item.type === 'audio') {
        // start audio
        audioPlayer.src = item.src;
        audioPlayer.loop = false;
        // remove previous handlers
        audioPlayer.onended = () => {
          if (typeof item.onEnded === 'function') {
            try { item.onEnded(); } catch (e) { console.error(e); }
          }
          currentMedia = null;
          // next item
          const next = mediaQueue.shift();
          if (next) startMedia(next);
        };
        audioPlayer.play().catch((err) => {
          // If play is blocked (autoplay policy), we'll still treat it as ended so queued videos won't stall forever.
          // But prefer to wait if it's user gesture. For simplicity, if it's blocked, call onEnded immediately.
          console.warn('Audio play blocked or failed:', err);
          audioPlayer.onended();
        });
      } else if (item.type === 'video') {
        // start video on the promptVideo element
        // Make sure previous handlers are removed
        promptVideo.onended = null;
        // set src and load
        while (promptVideo.firstChild) promptVideo.removeChild(promptVideo.firstChild);
        const src = document.createElement('source');
        src.src = item.src;
        src.type = 'video/mp4';
        promptVideo.appendChild(src);
        try { promptVideo.load(); } catch (e) {}
        promptVideo.loop = false;
        promptVideo.onended = () => {
          if (typeof item.onEnded === 'function') {
            try { item.onEnded(); } catch (e) { console.error(e); }
          }
          currentMedia = null;
          const next = mediaQueue.shift();
          if (next) startMedia(next);
        };
        // attempt play; if blocked, call onended so queue continues
        promptVideo.play().catch((err) => {
          console.warn('Video play blocked or failed:', err);
          // If play is blocked, try to unmute if user interacted (optional), otherwise treat it as ended to avoid deadlocks.
          if (typeof item.onEnded === 'function') {
            try { item.onEnded(); } catch (e) { console.error(e); }
          }
          currentMedia = null;
          const next = mediaQueue.shift();
          if (next) startMedia(next);
        });
      }
    }

    // Convenience wrappers
    function playAudioQueued(src, onEnded = null) {
      enqueueMedia({ type: 'audio', src, onEnded });
    }
    function playVideoQueued(src, onEnded = null) {
      enqueueMedia({ type: 'video', src, onEnded });
    }

    // ------------------------------
    // Game state + UI
    // ------------------------------
    let videoQueue = [];
    let lastVideo = null;
    let streak = 0;
    let totalPoints = 0;
    let scoreMarkers = [];
    let gameWon = false;
    let celebrationInProgress = false;

    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function getNextWhatisthisVideo() {
      if (videoQueue.length <= 1) {
        videoQueue = shuffleArray(whatisthisVideos.slice());
        if (videoQueue[0] === lastVideo && videoQueue.length > 1) {
          [videoQueue[0], videoQueue[1]] = [videoQueue[1], videoQueue[0]];
        }
      }
      lastVideo = videoQueue[0];
      return videoQueue.shift();
    }

    function setupScoreHeader() {
      const header = document.getElementById('score-header');
      header.innerHTML = '';
      scoreMarkers = [];
      for (let i = 0; i < streakLength; i++) {
        const div = document.createElement('div');
        div.className = 'score-marker';
        div.innerHTML = '<span class="star-empty">‚≠ê</span>';
        header.appendChild(div);
        scoreMarkers.push(div);
      }
      const pointsDiv = document.createElement('div');
      pointsDiv.className = 'points-display';
      pointsDiv.innerHTML = `<div class="points-label">Points</div><div class="points-value" id="points-counter">0</div>`;
      header.appendChild(pointsDiv);
      document.getElementById('points-counter').textContent = totalPoints;
      for (let i=0; i<streak; ++i) scoreMarkers[i].innerHTML = '‚≠ê';
    }
    function animateStarToProgressBar(targetMarkerIndex) {
      scoreMarkers[targetMarkerIndex].innerHTML = '‚≠ê';
    }
    function removeLastStar() {
      for (let i = streakLength-1; i >= 0; i--) {
        if (scoreMarkers[i].innerHTML !== '<span class=\"star-empty\">‚≠ê</span>' && scoreMarkers[i].innerHTML !== '') {
          scoreMarkers[i].innerHTML = '<span class="star-empty">‚≠ê</span>';
          break;
        }
      }
    }
    function resetGame() {
      gameWon = false;
      celebrationInProgress = false;
      totalPoints = 0;
      streak = 0;
      document.querySelector('.app-header').classList.remove('hide-celebration');
      document.getElementById('score-header').classList.remove('hide-celebration');
      document.querySelector('.controls').classList.remove('hide-celebration');
      document.getElementById('audio-cards').classList.remove('hide-celebration');
      document.getElementById('noun-img-container').classList.remove('hide-celebration');
      setupScoreHeader();
      loadNewRound();
    }
    function playCelebration() {
      gameWon = true;
      celebrationInProgress = true;
      document.querySelector('.app-header').classList.add('hide-celebration');
      document.getElementById('score-header').classList.add('hide-celebration');
      document.querySelector('.controls').classList.add('hide-celebration');
      document.getElementById('audio-cards').classList.add('hide-celebration');
      document.getElementById('noun-img-container').classList.add('hide-celebration');

      // enqueue celebration video so it doesn't start until any current audio finishes
      playVideoQueued(celebrationVideo, () => {
        setTimeout(() => { resetGame(); }, 400);
      });
    }
    function updateScoreHeader(isCorrect) {
      if (gameWon || celebrationInProgress) return;
      if (isCorrect) {
        animateStarToProgressBar(streak);
        streak++;
        if (streak === streakLength) {
          totalPoints++;
          updatePointsDisplay();
          if (totalPoints === pointsGoal) {
            playCelebration();
            return;
          } else {
            streak = 0;
            setTimeout(() => { setupScoreHeader(); }, 600);
          }
        }
      } else if (streak > 0) {
        removeLastStar();
        streak--;
      }
    }
    function updatePointsDisplay() {
      const pointsCounter = document.getElementById('points-counter');
      if (pointsCounter)
        pointsCounter.textContent = totalPoints;
    }

    // ------------------------------
    // Core game flow (use queued playback wrappers)
    // ------------------------------
    function loadNewRound() {
      if (gameWon || celebrationInProgress) return;
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      document.getElementById('noun-img').src = noun.img;
      document.getElementById('noun-img').setAttribute('data-noun', noun.name);

      // Request the next "whatisthis" video to play (queued)
      const videoUrl = getNextWhatisthisVideo();
      playVideoQueued(videoUrl, null); // no special onEnded logic for prompt video

      let incorrect;
      do { incorrect = nouns[Math.floor(Math.random() * nouns.length)]; }
      while (incorrect.name === noun.name);

      let audioCards = [
        { name: noun.name, audio: noun.audio, correct: true },
        { name: incorrect.name, audio: incorrect.audio, correct: false }
      ];
      audioCards.sort(() => Math.random() - 0.5);
      const audioCardsDiv = document.getElementById('audio-cards');
      audioCardsDiv.innerHTML = '';
      audioCards.forEach((card) => {
        const div = document.createElement('div');
        div.className = 'audio-card';
        div.setAttribute('draggable', true);
        div.setAttribute('data-correct', card.correct);
        div.setAttribute('data-audio', card.audio);
        div.innerHTML = `<span>${card.name}</span>
          <button onclick="event.stopPropagation(); playAudio('${card.audio}')">üîà</button>`;
        div.addEventListener('dragstart', function(e){
          if (gameWon || celebrationInProgress) { e.preventDefault(); return; }
          // Play the audio but via the queued player to avoid overlap:
          playAudio(card.audio);
          e.dataTransfer.setData('text/plain', card.correct);
          div.classList.add('dragging');
        });
        div.addEventListener('dragend', function(e){ div.classList.remove('dragging'); });
        audioCardsDiv.appendChild(div);
      });
      let nounImg = document.getElementById('noun-img');
      nounImg.ondragover = e => e.preventDefault();
      nounImg.ondrop = function(e){
        e.preventDefault();
        if (gameWon || celebrationInProgress) return;
        const correct = (e.dataTransfer.getData('text/plain') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false);}
      };
      for (let i = 0; i < streak; ++i) animateStarToProgressBar(i);
    }

    // ------------------------------
    // Public play helpers used in UI
    // These call the queued versions to ensure no overlapping.
    // ------------------------------
    function playAudio(src, onEnded = null) {
      if (gameWon || celebrationInProgress) return;
      playAudioQueued(src, onEnded);
    }
    function playPromptVideo() {
      if (gameWon || celebrationInProgress) return;
      // replay the currently loaded prompt video, if any, via the queue.
      // If promptVideo currently has a source and nothing is playing, we can start it;
      // otherwise, enqueue it so it plays after current media.
      // We prefer to use the src from the <source> element if present.
      const sourceEl = promptVideo.querySelector('source');
      const src = sourceEl ? sourceEl.src : getNextWhatisthisVideo();
      playVideoQueued(src, null);
    }
    function playFeedback(isCorrect) {
      if (gameWon || celebrationInProgress) return;
      const videoSrc = isCorrect ? feedbackVideos[0] : feedbackVideos[1];
      // Play the feedback video via the queue and run scoring logic after it ends.
      playVideoQueued(videoSrc, function() {
        if (isCorrect) updateScoreHeader(true);
        setTimeout(loadNewRound, 500);
      });
    }

    // ------------------------------
    // Touch drag support (play audio via queue to avoid overlap)
    // ------------------------------
    let touchItem = null;
    let dragClone = null;
    document.addEventListener('touchstart', function(e) {
      const card = e.target.closest('.audio-card');
      if (card && !(gameWon || celebrationInProgress)) {
        touchItem = card;
        card.classList.add('touching');
        // Play audio via queued player (it will wait for any playing video to finish)
        playAudio(card.getAttribute('data-audio'));
        dragClone = card.cloneNode(true);
        dragClone.className = "audio-card drag-clone";
        dragClone.style.width = card.offsetWidth + "px";
        dragClone.style.height = card.offsetHeight + "px";
        document.body.appendChild(dragClone);
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - card.offsetWidth/2) + "px";
        dragClone.style.top = (touch.clientY - card.offsetHeight/2) + "px";
      }
    },{passive:false});
    document.addEventListener('touchmove', function(e) {
      if (dragClone && touchItem) {
        e.preventDefault();
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - dragClone.offsetWidth/2) + "px";
        dragClone.style.top = (touch.clientY - dragClone.offsetHeight/2) + "px";
      }
    },{passive:false});
    document.addEventListener('touchend', function(e) {
      if (dragClone) dragClone.remove();
      dragClone = null;
      const touch = e.changedTouches[0];
      const nounImg = document.getElementById('noun-img');
      const rect = nounImg.getBoundingClientRect();
      if (
        touchItem &&
        touch.clientX >= rect.left && touch.clientX <= rect.right &&
        touch.clientY >= rect.top && touch.clientY <= rect.bottom
      ) {
        const correct = (touchItem.getAttribute('data-correct') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false);}
      }
      if (touchItem) touchItem.classList.remove('touching');
      touchItem = null;
    },{passive:false});

    // ------------------------------
    // Init: setup UI and pre-build video queue
    // ------------------------------
    function buildVideoQueue() {
      videoQueue = shuffleArray(whatisthisVideos.slice());
      if (videoQueue[0] === lastVideo && videoQueue.length > 1) {
        [videoQueue[0], videoQueue[1]] = [videoQueue[1], videoQueue[0]];
      }
    }

    (function init() {
      setupScoreHeader();
      buildVideoQueue();
      // Optionally prefetch the feedback & celebration clips by creating a muted audio/video
      // This is not required for the queue logic, but can help reduce perceived latency.
      // keep it small and conservative.
      try {
        if (!(navigator.connection && navigator.connection.saveData)) {
          const pre1 = document.createElement('link');
          pre1.rel = 'preload'; pre1.as = 'video'; pre1.href = feedbackVideos[0]; pre1.type = 'video/mp4';
          document.head.appendChild(pre1);
          const pre2 = document.createElement('link');
          pre2.rel = 'preload'; pre2.as = 'video'; pre2.href = feedbackVideos[1]; pre2.type = 'video/mp4';
          document.head.appendChild(pre2);
        }
      } catch (e) { /* ignore */ }

      loadNewRound();
    })();
  </script>
</body>
</html>
