<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Noun Game ‚Äî Star Fly + Sparkle Animation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <meta name="color-scheme" content="only light">
  <style>
    :root{
      --max-app-width: 1200px;
      --gutter: 1.25rem;
      --accent: #2563EB;
      --accent-2: #FF6B35;
      --card-gap: 1rem;
      --section-vertical-gap: 1.25rem;
    }

    /* Reset / base */
    html,body{height:100%;margin:0;padding:0;background:#fff;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;-webkit-font-smoothing:antialiased;}
    img,video{max-width:100%;display:block;height:auto}
    button{font:inherit}

    /* App container ‚Äî center and cap width on large screens */
    .app-wrapper{
      width: min(var(--max-app-width), 100%);
      margin: 0 auto;
      padding: calc(var(--gutter) * 1.2);
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap:var(--section-vertical-gap);
      min-height:100vh;
      align-items:center;
      background:#fff;
    }

    /* Header */
    .app-header { text-align:center; padding: 0; width:100%; }
    .app-header h1 { margin: 0 0 .25rem 0; font-weight:800; color:#111; font-size:clamp(1.4rem, 5.5vw, 2.3rem); }
    .app-header p { margin: 0; color:#444; font-size:clamp(.9rem, 4vw, 1.1rem); }

    /* Score row - centered above everything */
    #score-header {
      display:flex;
      gap: .75rem;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      width:100%;
      margin-top: .25rem;
      margin-bottom: .25rem;
    }
    .score-marker { width:48px; height:48px; border-radius:8px; border:2px solid var(--accent-2); display:flex; align-items:center; justify-content:center; background:#fff; box-sizing:border-box; overflow:hidden; }
    .score-marker .star-empty{ opacity:.28; filter:grayscale(1); font-size:1.1rem; }
    .score-marker img.small-star{ width: 100%; height: 100%; object-fit:contain; display:block; }

    .points-display { background:var(--accent); color:#fff; padding: .5rem .9rem; border-radius:12px; font-weight:700; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:96px;}
    .points-label{font-size:.6rem; text-transform:uppercase; opacity:.95}
    .points-value{font-size:1.35rem; line-height:1; font-weight:900;}

    /* Game area */
    #game-container{ width:100%; display:flex; flex-direction:column; gap:var(--section-vertical-gap); align-items:center; }
    .game-content{ width:100%; display:flex; justify-content:center; }
    #content-wrapper{ width:100%; display:flex; flex-direction:column; gap:var(--section-vertical-gap); align-items:center; }

    /* Video + noun wrapper
       NOTE: ensure the .video-wrapper reserves space in the layout so controls below it stay below.
       Use aspect-ratio (modern browsers) and fallback min-height so the absolutely positioned
       videos don't collapse the wrapper to zero height and overlap the controls.
    */
    #video-section{ width:100%; display:flex; flex-direction:column; align-items:center; gap:var(--section-vertical-gap); position:relative; }
    .video-wrapper{
      width:100%;
      max-width: 980px;
      position:relative;
      display:block;
      box-sizing:border-box;
      padding: 0;
      cursor:pointer;
      background: transparent; /* ensure transparent to avoid black background */
      border-radius:12px;
      overflow:visible;

      /* Reserve space so the absolutely-positioned video(s) don't overlap following content */
      aspect-ratio: 16 / 9; /* modern browsers */
      min-height: 220px;    /* fallback for older browsers */
    }

    /* Two stacked videos for smooth crossfades */
    .prompt-video {
      width:100%;
      height:100%;
      object-fit:contain;
      border-radius:12px;
      background: transparent; /* avoid black background when swapping sources */
      display:block;
      box-shadow: 0 12px 30px rgba(0,0,0,0.08);
      position:absolute; /* stack inside wrapper but wrapper now reserves height */
      left:0;
      top:0;
      transition: opacity 260ms cubic-bezier(.22,.9,.3,1);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      will-change: opacity;
      opacity:0;
      pointer-events:none;
      z-index:2; /* behind noun image and above page background */
    }

    /* the "visible" video is interactive */
    .prompt-video.visible { opacity:1; pointer-events:auto; }

    /* Noun card absolutely positioned over the video-wrapper so it always overlaps the video.
       Keep it above videos with a higher z-index so it remains interactive.
    */
    #noun-img-container{
      position:absolute;
      top: 6%;
      right: 6%;
      z-index: 6; /* above videos */
      width: 36vw;
      max-width: 260px;
      pointer-events: auto;
      display:flex;
      justify-content:flex-end;
      align-items:flex-start;
      transform: translateZ(0);
      transition: all .18s ease;
    }
    .noun-img{
      width:100%;
      height:auto;
      border-radius:14px;
      padding:.7rem;
      background:#f3f3f3;
      border:3px solid var(--accent-2);
      box-sizing:border-box;
      box-shadow: 0 14px 36px rgba(0,0,0,0.12);
    }

    /* Controls + audio cards group that always sits BELOW the video (stacked vertically)
       Make sure these have a lower z-index than the video wrapper so they appear visually below.
    */
    .bottom-controls {
      width:100%;
      max-width: 980px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: var(--card-gap);
      padding: .75rem 0;
      box-sizing:border-box;
      z-index:1; /* ensure below videos and noun image */
      position:relative; /* normal flow under .video-wrapper */
    }
    .controls { width:100%; display:flex; justify-content:center; align-items:center; padding:0; gap:.75rem; }
    .btn-replay{
      padding:.9rem 1rem;
      border-radius:14px;
      border:none;
      background:var(--accent);
      color:#fff;
      font-weight:800;
      font-size:1.02rem;
      box-shadow: 0 8px 24px rgba(37,99,235,.08);
      cursor:pointer;
      min-width: 220px;
      max-width: 420px;
      width: 55%;
    }

    /* Audio cards: centered below the video, with consistent gap/padding */
    #audio-cards{
      width:100%;
      display:flex;
      justify-content:center;
      gap: var(--card-gap);
      flex-wrap:wrap;
      padding: .4rem 0;
      box-sizing:border-box;
      z-index:1;
    }
    .audio-card{
      display:flex;
      align-items:center;
      gap:.6rem;
      padding:.85rem 1rem;
      border-radius:12px;
      background:#f3f3f3;
      cursor:grab;
      border:3px solid var(--accent);
      min-width:160px;
      max-width:320px;
      box-sizing:border-box;
      transition: transform .12s, box-shadow .12s;
    }
    .audio-card:active, .audio-card.touching { transform: translateY(-3px); box-shadow: 0 12px 30px rgba(37,99,235,.08); }
    .audio-card span{ font-weight:800; letter-spacing:.04em; font-size:clamp(.8rem, 3.6vw, 1.02rem); text-transform:uppercase; color:#222; }
    .audio-card button{ width:42px; height:42px; border-radius:999px; border:2px solid var(--accent); background:rgba(0,0,0,.05); color:var(--accent); display:flex; align-items:center; justify-content:center; cursor:pointer; }

    /* Drag clone */
    .drag-clone{ position:fixed; pointer-events:none; z-index:9999; transform:scale(1.06); box-shadow:0 20px 40px rgba(0,0,0,.12); border-radius:12px; }

    /* Flying star (large) used for animation */
    .flying-star {
      position: fixed;
      z-index: 10000;
      pointer-events: none;
      background-image: url('img/star.png');
      background-size: contain;
      background-repeat: no-repeat;
      will-change: left, top, transform, opacity;
      transition: left 1s cubic-bezier(.22,.9,.3,1), top 1s cubic-bezier(.22,.9,.3,1), transform 1s cubic-bezier(.22,.9,.3,1), opacity 0.6s ease;
      filter: drop-shadow(0 12px 20px rgba(0,0,0,.18));
    }
    /* small sparkle dots inside the flying star */
    .flying-star .spark {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 30%, #fff 0%, #ffd86b 30%, rgba(255,214,107,0) 60%);
      opacity: 0;
      pointer-events: none;
      transform: scale(0.4);
      animation: spark 1100ms linear forwards;
    }
    @keyframes spark {
      0% { opacity: 1; transform: scale(0.3) translateY(0) rotate(0); }
      40% { opacity: 1; transform: scale(1.1) translateY(-18px) rotate(30deg); }
      100% { opacity: 0; transform: scale(0.2) translateY(-36px) rotate(90deg); }
    }

    /* Desktop adjustments */
    @media (min-width:900px){
      .video-wrapper{ max-width: 1100px; aspect-ratio: 16/9; }
      .prompt-video{ max-height:72vh; border-radius:16px; }
      #noun-img-container{
        top: 10%;
        right: 6%;
        width: 24%;
        max-width: 320px;
      }
      .bottom-controls { padding: 1rem 0; gap: 1rem; }
      .btn-replay{ width: 320px; }
      #audio-cards{ gap: 1rem; justify-content:flex-start; }
      .audio-card{ min-width:180px; }
    }

    /* Small screens tiny adjustments */
    @media (max-width:360px){
      #noun-img-container{ width:44vw; max-width:160px; top:4%; right:4%; }
      .btn-replay{ width:68%; min-width: 160px; }
    }
  </style>
</head>
<body>
  <div class="app-wrapper">
    <div class="app-header">
      <h1>üéÆ Noun Game</h1>
      <p>Â∞ÜÈü≥È¢ëÂç°ÊãñÂà∞ÂõæÁâá‰∏ä</p>
    </div>

    <!-- Progress (streak markers) and Points centered above everything -->
    <div id="score-header" aria-live="polite"></div>

    <div id="game-container">
      <div class="game-content">
        <div id="content-wrapper">

          <div id="video-section">
            <div class="video-wrapper" id="video-wrapper" aria-hidden="false" title="Click to play with sound">
              <!-- Two stacked videos for crossfading to avoid black flashes -->
              <video id="prompt-video-a" class="prompt-video" playsinline preload="metadata" ></video>
              <video id="prompt-video-b" class="prompt-video" playsinline preload="metadata" ></video>

              <div id="noun-img-container">
                <img id="noun-img" class="noun-img" src="" alt="noun">
              </div>
            </div>

            <div class="bottom-controls" role="group" aria-label="controls and audio cards">
              <div class="controls">
                <button class="btn-replay" id="start-btn">ÂºÄÂßãËßÜÈ¢ë</button>
              </div>
              <div id="audio-cards" aria-label="audio cards"></div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    /* ---------- DATA ---------- */
    const nouns = [
      { name: 'butterfly', img: 'img/Butterfly.png', audio: 'audio/butterfly.mp3' },
      { name: 'duck', img: 'img/duck.png', audio: 'audio/duck.mp3' },
      { name: 'turtle', img: 'img/turtle.png', audio: 'audio/turtle.mp3' },
      { name: 'frog', img: 'img/frog.png', audio: 'audio/frog.mp3' },
      { name: 'dolphin', img: 'img/dolphin.png', audio: 'audio/dolphin.mp3' },
      { name: 'fish', img: 'img/fish.png', audio: 'audio/fish.mp3' },
      { name: 'bee', img: 'img/bee.png', audio: 'audio/bee.mp3' },
      { name: 'plane', img: 'img/plane.png', audio: 'audio/plane.mp3' },
      { name: 'bat', img: 'img/bat.png', audio: 'audio/bat.mp3' },
      { name: 'bird', img: 'img/bird.png', audio: 'audio/bird.mp3' }
    ];
    const whatisthisVideos = ['vid/whatisthis.mp4', 'vid/whatisthis1.mp4', 'vid/whatisthis2.mp4'];
    const celebrationVideo = 'vid/greatjob.mp4';
    const feedbackVideos = ['vid/thatscorrect.mp4', 'vid/betterluck.mp4'];
    const STAR_SRC = 'img/star.png'; // user-provided star image used for progress and animation

    /* ---------- STATE / MEDIA PLAYBACK (with double-buffered video to avoid black flash) ---------- */
    const videoA = document.getElementById('prompt-video-a');
    const videoB = document.getElementById('prompt-video-b');
    videoA.muted = true;
    videoB.muted = true;

    // The video element currently visible/active and the standby element we prepare next media on.
    let activeVideoEl = videoA;
    let standbyVideoEl = videoB;

    const audioPlayer = new Audio();
    audioPlayer.preload = 'auto';

    let userInteracted = false;   // becomes true when user clicks Start or the video wrapper
    let mediaQueue = [];          // FIFO queue of {type:'audio'|'video', src, onEnded, onStart}
    let currentMedia = null;

    function setUserInteracted() {
      if (userInteracted) return;
      userInteracted = true;
      try { audioPlayer.muted = false; videoA.muted = false; videoB.muted = false; } catch(e){}
      if (!currentMedia) {
        const next = mediaQueue.shift();
        if (next) startMedia(next);
      }
    }

    // attach gesture handlers to start button and video-wrapper
    document.getElementById('start-btn').addEventListener('click', function (e) {
      e.stopPropagation();
      setUserInteracted();
      playPromptVideo();
    });
    document.getElementById('video-wrapper').addEventListener('click', function (e) {
      setUserInteracted();
      playPromptVideo();
    });

    function enqueueMedia(item) {
      // item: { type, src, onEnded, onStart }
      if (!currentMedia) startMedia(item);
      else mediaQueue.push(item);
    }

    /* Smooth video playback using two elements and crossfade.
       We never remove or swap <source> nodes while the visible video is being removed.
       Instead we load the next src into the standby element, wait for it to be ready to play,
       start it, crossfade by toggling CSS classes, then pause the old element and swap references.
    */
    const CROSSFADE_DURATION = 260; // should match CSS transition

    function playVideoSmooth(src, onEnded = null, onStart = null) {
      const playEl = standbyVideoEl;
      const prevEl = activeVideoEl;

      // Clean up previous handlers on playEl
      playEl.oncanplay = null;
      playEl.onplaying = null;
      playEl.onended = null;
      playEl.onerror = null;

      // set src and prepare
      if (playEl.getAttribute('data-loaded-src') !== src) {
        try {
          playEl.pause();
        } catch(e){}
        playEl.removeAttribute('src');
        playEl.load && playEl.load();
        playEl.src = src;
        playEl.setAttribute('data-loaded-src', src);
        try { playEl.load(); } catch (e) {}
      }

      // ensure mute state follows user gesture
      playEl.muted = !userInteracted;

      // attach handlers
      const started = () => {
        if (typeof onStart === 'function') {
          try { onStart(); } catch(e){ console.error(e); }
        }
      };

      playEl.onplaying = started;

      playEl.onended = () => {
        if (typeof onEnded === 'function') {
          try { onEnded(); } catch(e){ console.error(e); }
        }
        currentMedia = null;
        const next = mediaQueue.shift();
        if (next) startMedia(next);
      };

      const startWhenReady = () => {
        try { playEl.currentTime = 0; } catch(e){}
        const p = playEl.play();
        if (p && typeof p.then === 'function') {
          p.then(() => {
            playEl.classList.add('visible');
            prevEl.classList.remove('visible');

            setTimeout(() => {
              try { prevEl.pause(); } catch(e){}
              standbyVideoEl = prevEl;
              activeVideoEl = playEl;
            }, CROSSFADE_DURATION + 20);
          }).catch(err => {
            console.warn('Video play blocked or failed:', err);
            playEl.onended && playEl.onended();
          });
        } else {
          playEl.classList.add('visible');
          prevEl.classList.remove('visible');
          setTimeout(() => {
            try { prevEl.pause(); } catch(e){}
            standbyVideoEl = prevEl;
            activeVideoEl = playEl;
          }, CROSSFADE_DURATION + 20);
        }
      };

      if (playEl.readyState >= 3) startWhenReady();
      else {
        const onCanPlay = () => {
          playEl.removeEventListener('canplay', onCanPlay);
          startWhenReady();
        };
        playEl.addEventListener('canplay', onCanPlay);
      }
    }

    function startMedia(item) {
      currentMedia = item;
      if (!item) return;
      if (item.type === 'audio') {
        audioPlayer.src = item.src;
        audioPlayer.loop = false;
        audioPlayer.onended = () => {
          if (typeof item.onEnded === 'function') try { item.onEnded(); } catch(e){console.error(e);}
          currentMedia = null;
          const next = mediaQueue.shift();
          if (next) startMedia(next);
        };
        audioPlayer.muted = !userInteracted;
        audioPlayer.play().catch(err => {
          console.warn('Audio play blocked or failed:', err);
          audioPlayer.onended && audioPlayer.onended();
        });
      } else if (item.type === 'video') {
        playVideoSmooth(item.src, item.onEnded, item.onStart);
      }
    }

    function playAudioQueued(src, onEnded = null) { enqueueMedia({ type: 'audio', src, onEnded }); }
    function playVideoQueued(src, onEnded = null, onStart = null) { enqueueMedia({ type: 'video', src, onEnded, onStart }); }

    /* ---------- SCORING & UI ---------- */
    const streakLength = 5;
    const pointsGoal = 3;
    let videoQueue = [];
    let lastVideo = null;
    let streak = 0, totalPoints = 0;
    let scoreMarkers = [];
    let gameWon = false, celebrationInProgress = false;

    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function setupScoreHeader() {
      const header = document.getElementById('score-header');
      header.innerHTML = '';
      scoreMarkers = [];
      for (let i = 0; i < streakLength; i++) {
        const div = document.createElement('div');
        div.className = 'score-marker';
        div.innerHTML = '<span class="star-empty">‚≠ê</span>';
        header.appendChild(div);
        scoreMarkers.push(div);
      }
      const pointsDiv = document.createElement('div');
      pointsDiv.className = 'points-display';
      pointsDiv.innerHTML = `<div class="points-label">Points</div><div class="points-value" id="points-counter">0</div>`;
      header.appendChild(pointsDiv);
      document.getElementById('points-counter').textContent = totalPoints;
      for (let i = 0; i < streak; ++i) scoreMarkers[i].innerHTML = `<img src="${STAR_SRC}" class="small-star" alt="star">`;
    }

    function animateStarToProgressBarIndex(targetIndex) {
      if (!scoreMarkers[targetIndex]) return;
      scoreMarkers[targetIndex].innerHTML = `<img src="${STAR_SRC}" class="small-star" alt="star">`;
    }

    function resetGame() {
      gameWon = false;
      celebrationInProgress = false;
      totalPoints = 0;
      streak = 0;
      setupScoreHeader();
      loadNewRound();
    }

    function playCelebration() {
      gameWon = true;
      celebrationInProgress = true;
      playVideoQueued(celebrationVideo, () => { setTimeout(() => { resetGame(); }, 400); });
    }

    function updateScoreHeader(isCorrect) {
      if (gameWon || celebrationInProgress) return;
      if (isCorrect) {
        streak++;
        if (streak - 1 >= 0) animateStarToProgressBarIndex(streak - 1);

        if (streak === streakLength) {
          totalPoints++;
          updatePointsDisplay();
          if (totalPoints === pointsGoal) {
            playCelebration();
            return;
          } else {
            streak = 0;
            setTimeout(() => { setupScoreHeader(); }, 600);
          }
        }
      } else {
        if (streak > 0) {
          for (let i = scoreMarkers.length - 1; i >= 0; i--) {
            const marker = scoreMarkers[i];
            if (marker.innerHTML.trim() !== '') {
              marker.innerHTML = '<span class="star-empty">‚≠ê</span>';
              break;
            }
          }
          streak--;
        }
      }
    }

    function updatePointsDisplay() {
      const el = document.getElementById('points-counter');
      if (el) el.textContent = totalPoints;
    }

    /* ---------- STAR FLY ANIMATION ---------- */
    function flyStarFromNounToMarker(targetIndex, doneCallback) {
      const nounImg = document.getElementById('noun-img');
      const marker = scoreMarkers[targetIndex];
      if (!nounImg || !marker) {
        if (typeof doneCallback === 'function') doneCallback();
        return;
      }

      const nounRect = nounImg.getBoundingClientRect();
      const startX = nounRect.left + nounRect.width / 2;
      const startY = nounRect.top + nounRect.height / 2;

      const markerRect = marker.getBoundingClientRect();
      const targetX = markerRect.left + markerRect.width / 2;
      const targetY = markerRect.top + markerRect.height / 2;

      const maxSize = Math.min(320, Math.max(120, nounRect.width * 0.9));
      const starSize = Math.round(maxSize);

      const star = document.createElement('div');
      star.className = 'flying-star';
      star.style.width = star.style.height = starSize + 'px';
      star.style.left = (startX - starSize / 2) + 'px';
      star.style.top = (startY - starSize / 2) + 'px';
      star.style.transform = 'scale(1.15) rotate(0deg)';
      star.style.opacity = '1';

      const sparks = [];
      const sparkCount = 6;
      for (let i = 0; i < sparkCount; i++) {
        const s = document.createElement('div');
        s.className = 'spark';
        const rx = Math.round((Math.random() * 60) + 10);
        const ry = Math.round((Math.random() * 60) + 10);
        s.style.left = rx + 'px';
        s.style.top = ry + 'px';
        s.style.animationDelay = (i * 110) + 'ms';
        star.appendChild(s);
        sparks.push(s);
      }

      document.body.appendChild(star);
      star.getBoundingClientRect();

      const moveDelay = 150;
      setTimeout(() => {
        star.style.left = (targetX - starSize * 0.28) + 'px';
        star.style.top = (targetY - starSize * 0.28) + 'px';
        star.style.transform = 'scale(0.36) rotate(25deg)';
        star.style.opacity = '0.95';
      }, moveDelay);

      const cleanup = () => {
        if (scoreMarkers[targetIndex]) scoreMarkers[targetIndex].innerHTML = `<img src="${STAR_SRC}" class="small-star" alt="star">`;
        star.style.transition = 'opacity .25s ease';
        star.style.opacity = '0';
        setTimeout(() => {
          star.remove();
          if (typeof doneCallback === 'function') doneCallback();
        }, 300);
      };

      let onTransitionEnd = (ev) => {
        if (ev.propertyName === 'left' || ev.propertyName === 'top') {
          star.removeEventListener('transitionend', onTransitionEnd);
          cleanup();
        }
      };
      star.addEventListener('transitionend', onTransitionEnd);

      setTimeout(() => {
        if (document.body.contains(star)) {
          cleanup();
        }
      }, 1500);
    }

    /* ---------- CORE GAME FLOW (random prompt selection per noun reload) ---------- */
    function pickRandomPromptVideo() {
      const idx = Math.floor(Math.random() * whatisthisVideos.length);
      return whatisthisVideos[idx];
    }

    function loadNewRound() {
      if (gameWon || celebrationInProgress) return;
      const noun = nouns[Math.floor(Math.random() * nouns.length)];
      document.getElementById('noun-img').src = noun.img;
      document.getElementById('noun-img').setAttribute('data-noun', noun.name);

      const videoUrl = pickRandomPromptVideo();
      lastVideo = videoUrl;

      // If user has interacted already, enqueue the prompt to play. Otherwise prepare metadata/frame on standby
      if (userInteracted) {
        playVideoQueued(videoUrl, null);
      } else {
        try {
          standbyVideoEl.pause();
          standbyVideoEl.removeAttribute('src');
          standbyVideoEl.src = videoUrl;
          standbyVideoEl.setAttribute('data-loaded-src', videoUrl);
          standbyVideoEl.load && standbyVideoEl.load();
        } catch (e) { /* ignore */ }
      }

      // choose incorrect card
      let incorrect;
      do { incorrect = nouns[Math.floor(Math.random() * nouns.length)]; } while (incorrect.name === noun.name);

      const audioCards = [
        { name: noun.name, audio: noun.audio, correct: true },
        { name: incorrect.name, audio: incorrect.audio, correct: false }
      ];
      audioCards.sort(() => Math.random() - 0.5);

      const audioCardsDiv = document.getElementById('audio-cards');
      audioCardsDiv.innerHTML = '';
      audioCards.forEach((card) => {
        const div = document.createElement('div');
        div.className = 'audio-card';
        div.setAttribute('draggable', true);
        div.setAttribute('data-correct', card.correct);
        div.setAttribute('data-audio', card.audio);
        div.innerHTML = `<span>${card.name}</span>
          <button onclick="event.stopPropagation(); playAudio('${card.audio}')">üîà</button>`;
        div.addEventListener('dragstart', function (e) {
          if (gameWon || celebrationInProgress) { e.preventDefault(); return; }
          setUserInteracted(); // treat drag as gesture
          playAudio(card.audio);
          e.dataTransfer.setData('text/plain', card.correct);
          div.classList.add('dragging');
        });
        div.addEventListener('dragend', function () { div.classList.remove('dragging'); });
        audioCardsDiv.appendChild(div);
      });

      let nounImg = document.getElementById('noun-img');
      nounImg.ondragover = e => e.preventDefault();
      nounImg.ondrop = function (e) {
        e.preventDefault();
        if (gameWon || celebrationInProgress) return;
        const correct = (e.dataTransfer.getData('text/plain') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false); }
      };

      for (let i = 0; i < streak; ++i) animateStarToProgressBarIndex(i);
    }

    /* ---------- PLAY HELPERS ---------- */
    function playAudio(src, onEnded = null) {
      setUserInteracted();
      if (gameWon || celebrationInProgress) return;
      playAudioQueued(src, onEnded);
    }

    function playPromptVideo() {
      if (gameWon || celebrationInProgress) return;
      const pending = standbyVideoEl.getAttribute('data-loaded-src');
      let src = pending || pickRandomPromptVideo();
      standbyVideoEl.removeAttribute('data-loaded-src');
      playVideoQueued(src, null);
    }

    function playFeedback(isCorrect) {
      if (gameWon || celebrationInProgress) return;

      if (isCorrect) {
        const targetIndex = streak;
        playVideoQueued(feedbackVideos[0], function () {
          updateScoreHeader(true);
          setTimeout(loadNewRound, 500);
        }, function onStart() {
          flyStarFromNounToMarker(targetIndex);
        });
      } else {
        playVideoQueued(feedbackVideos[1], function () {
          updateScoreHeader(false);
          setTimeout(loadNewRound, 500);
        });
      }
    }

    /* ---------- Touch drag support ---------- */
    let touchItem = null;
    let dragClone = null;
    document.addEventListener('touchstart', function (e) {
      const card = e.target.closest('.audio-card');
      if (card && !(gameWon || celebrationInProgress)) {
        touchItem = card;
        card.classList.add('touching');
        setUserInteracted();
        playAudio(card.getAttribute('data-audio'));
        dragClone = card.cloneNode(true);
        dragClone.className = "audio-card drag-clone";
        dragClone.style.width = card.offsetWidth + "px";
        dragClone.style.height = card.offsetHeight + "px";
        document.body.appendChild(dragClone);
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - card.offsetWidth / 2) + "px";
        dragClone.style.top = (touch.clientY - card.offsetHeight / 2) + "px";
      }
    }, { passive: false });
    document.addEventListener('touchmove', function (e) {
      if (dragClone && touchItem) {
        e.preventDefault();
        const touch = e.touches[0];
        dragClone.style.left = (touch.clientX - dragClone.offsetWidth / 2) + "px";
        dragClone.style.top = (touch.clientY - dragClone.offsetHeight / 2) + "px";
      }
    }, { passive: false });
    document.addEventListener('touchend', function (e) {
      if (dragClone) dragClone.remove();
      dragClone = null;
      const touch = e.changedTouches[0];
      const nounImg = document.getElementById('noun-img');
      const rect = nounImg.getBoundingClientRect();
      if (
        touchItem &&
        touch.clientX >= rect.left && touch.clientX <= rect.right &&
        touch.clientY >= rect.top && touch.clientY <= rect.bottom
      ) {
        const correct = (touchItem.getAttribute('data-correct') === 'true');
        if (correct) playFeedback(true);
        else { updateScoreHeader(false); playFeedback(false); }
      }
      if (touchItem) touchItem.classList.remove('touching');
      touchItem = null;
    }, { passive: false });

    /* ---------- INIT ---------- */
    (function init(){
      audioPlayer.muted = true;
      videoA.muted = true;
      videoB.muted = true;

      // ensure initial visual state: make active visible (even though it has no src yet)
      activeVideoEl.classList.add('visible');
      standbyVideoEl.classList.remove('visible');

      setupScoreHeader();
      loadNewRound();
    })();
  </script>
</body>
</html>
